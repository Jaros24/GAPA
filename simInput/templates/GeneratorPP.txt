#include "AtTPC20MgDecay.h"

#include <FairLogger.h> // for Logger, LOG
#include <FairPrimaryGenerator.h>

#include <TF1.h>
#include <TH1.h>
#include <TMath.h>
#include <TRandom.h>

#include <cmath>    // for acos
#include <iostream> // for operator<<, endl, basic_ostream, cout
#include <memory>   // for make_unique, unique_ptr

Bool_t AtTPC20MgDecay::Init()
{
   // Initialize generator
   return true;
}

// -----   Public method ReadEvent   --------------------------------------
Bool_t AtTPC20MgDecay::ReadEvent(FairPrimaryGenerator *primGen)
{
   srand((unsigned)time(NULL));
   UInt_t seed=(float)rand() / RAND_MAX * 1000000;
   gRandom->SetSeed(seed); // Seed
   if (fBoxVtxIsSet) {
      fX = gRandom->Uniform(fX1, fX2);
      fY = gRandom->Uniform(fY1, fY2);
      fZ = gRandom->Uniform(fZ1, fZ2);
   }

   // Proton of 1210keV and alpha of 506keV
   Int_t protonPDGID = 2212;
   Int_t alphaPDGID = 1000020040;
   Int_t gammaPDGID =22;
   Int_t betaPDGID =11;

   Double32_t ptProton1 = 0, pxProton1 = 0, pyProton1 = 0, pzProton1 = 0;
   Double32_t pabsProton1 = 0.0470; // P0 E0
   Double32_t brp1=1;
   Double32_t thetaProton1 = acos(gRandom->Uniform(-1, 1));
   Double32_t phiProton1 = gRandom->Uniform(0, 360) * TMath::DegToRad();
   pzProton1 = pabsProton1 * TMath::Cos(thetaProton1);
   ptProton1 = pabsProton1 * TMath::Sin(thetaProton1);
   pxProton1 = ptProton1 * TMath::Cos(phiProton1);
   pyProton1 = ptProton1 * TMath::Sin(phiProton1);

   Double32_t ptProton2 = 0, pxProton2 = 0, pyProton2 = 0, pzProton2 = 0;
   Double32_t pabsProton2 = 0.06162; // P1 E1
   Double32_t brp2=1;
   Double32_t thetaProton2 = acos(gRandom->Uniform(-1, 1));
   Double32_t phiProton2 = gRandom->Uniform(0, 360) * TMath::DegToRad();
   pzProton2 = pabsProton2 * TMath::Cos(thetaProton2);
   ptProton2 = pabsProton2 * TMath::Sin(thetaProton2);
   pxProton2 = ptProton2 * TMath::Cos(phiProton2);
   pyProton2 = ptProton2 * TMath::Sin(phiProton2);


   if (fNuclearDecayChainIsSet){

	if(!protonPDGID == 2212)
		LOG(fatal)<<"AtTPC20MgDecayGenerator:PDG code"<<protonPDGID<<"is not a proton!";
//if(protonPDGID == 2212)	
//      brp=gRandom->Uniform(0,1);

for (Int_t i =0; i<fParticlesDefinedInNuclearDecay; i++){
if(brp1<=1){
			Double32_t Proton1Momentum = TMath::Sqrt(pxProton1*pxProton1+pyProton1*pyProton1+pzProton1*pzProton1);
			pxProton1=pxProton1*fParticleEnergies[i]/Proton1Momentum;
			pyProton1=pyProton1*fParticleEnergies[i]/Proton1Momentum;
			pzProton1=pzProton1*fParticleEnergies[i]/Proton1Momentum;}
if(brp2<=1){
			Double32_t Proton2Momentum = TMath::Sqrt(pxProton2*pxProton2+pyProton2*pyProton2+pzProton2*pzProton2);
			pxProton2=pxProton2*fParticleEnergies[i]/Proton2Momentum;
			pyProton2=pyProton2*fParticleEnergies[i]/Proton2Momentum;
			pzProton2=pzProton2*fParticleEnergies[i]/Proton2Momentum;}
}


   primGen->AddTrack(22, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // dummy photon for track ID 0
   if(brp1<=1){
   primGen->AddTrack(protonPDGID, pxProton1,pyProton1,pzProton1,fX,fY,fZ);}

   if(brp2<=1){
   primGen->AddTrack(protonPDGID, pxProton2, pyProton2, pzProton2, fX, fY, fZ);}

}
   return kTRUE;
}

void AtTPC20MgDecay::SetDecayChainPoint(Double32_t ParticleEnergy, Double32_t ParticleBranchingRatio)
{
	for(Int_t i =0; i<fParticlesDefinedInNuclearDecay;i++){
		fParticleEnergies[i]=ParticleEnergy;
		fParticleBranchingRatios[i]=ParticleBranchingRatio;	
}
}

ClassImp(AtTPC20MgDecay)